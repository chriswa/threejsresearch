<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Proto</title>
		<style>
			html, body { margin: 0; overflow: hidden; }
			canvas { width: 100%; height: 100% }
			#coords { position: absolute; top: 0; right: 0; color: white; background-color: black; text-align: right; padding: 2px; }
			#crosshair { width: 10px; height: 20px; position: absolute; top: 50%; left: 50%; margin: -10px 0 0 -5px; color: white; text-align: center; }
		</style>
	</head>
	<body>
		<div id="coords"></div>
		<div id="crosshair">+</div>
		<script src="stats.js"></script>
		<script src="perlin.js"></script>
		<script src="three.js"></script>
		<script src="FirstPersonControls.js"></script>
		<script src="PlayerControls.js"></script>
		<script src="lodash.js"></script>
		<script src="Chunk.js"></script>
		<script src="BlockPos.js"></script>
		<script src="Sides.js"></script>
		<script src="BlockTypes.js"></script>
		<script src="World.js"></script>
		<script>
			var stats = {}
			stats.elapsed = new Stats()
			stats.elapsed.showPanel(1)
			stats.elapsed.domElement.style.position = 'absolute'
			stats.elapsed.domElement.style.top = '5px'
			document.body.appendChild( stats.elapsed.domElement )
			stats.fps = new Stats()
			stats.fps.showPanel(0)
			stats.fps.domElement.style.position = 'absolute'
			stats.fps.domElement.style.top = '5px'
			stats.fps.domElement.style.left = '80px'
			document.body.appendChild( stats.fps.domElement )


			var mainTexture
			var loader = new THREE.TextureLoader();
			
			var renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio( window.devicePixelRatio )
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			var scene  = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			camera.position.z = 7.5;
			camera.position.y = 4.5;
			camera.position.x = 7.5;

			window.addEventListener( 'resize', () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}, false );

			//var cube1 = new THREE.Mesh( new THREE.BoxGeometry( 1.1, 1.1, 1.1 ), new THREE.MeshBasicMaterial( {color: 0x0099cc} ) );
			//scene.add( cube1 );
			//var cube2 = new THREE.Mesh( new THREE.BoxGeometry( 0.2, 0.2, 0.2 ), new THREE.MeshBasicMaterial( {color: 0x99cc00} ) );
			//scene.add( cube2 );

			var voxelRaycast
			camera.addEventListener('click', event => {

				if (!voxelRaycast) { return }

				if (event.button === 0) {
					voxelRaycast.blockPos.setBlockData(0)
				}
				else {
					voxelRaycast.blockPos.getAdjacentBlockPos(voxelRaycast.side).setBlockData(BlockTypesByName.planks.id)
				}
			})

			loader.load('minecraft15.png', texture => { // e.g. loading multiple textures with promise.all: http://stackoverflow.com/questions/7919516/using-textures-in-three-js
				texture.minFilter = THREE.NearestFilter;
				texture.magFilter = THREE.NearestFilter;
				mainTexture = texture

				World.build() // requires mainTexture

				start()

				function start() {

					var raycaster = new THREE.Raycaster()

					var clock = new THREE.Clock()
					var elapsedTime = 0

					PlayerControls.init(camera)

					var lastPlayerChunkId = World.getBlockPosFromWorldPoint(camera.position).chunk.id

					var blockOutlineVerts = []
					Sides.each(side => {
						blockOutlineVerts = blockOutlineVerts.concat(side.verts).concat(side.verts.slice(0, 3))
					})
					var blockOutlineGeometry = new THREE.BufferGeometry()
					blockOutlineGeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array(blockOutlineVerts), 3 ) )
					var blockOutlineMaterial = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 1, transparent: true } )
					blockOutline = new THREE.Line( blockOutlineGeometry, blockOutlineMaterial )
					scene.add( blockOutline )



					var render = function () {
						stats.elapsed.begin()
						var dt = clock.getDelta()
						elapsedTime += dt

						//// spam block updates!
						//if (elapsedTime > 0.01) {
						//	elapsedTime -= 0.01
						//	//debugger;
						//	var x = Math.floor(Math.random() * Chunk.sizeX)
						//	var y = 3 // Math.floor(Math.random() * Chunk.sizeY)
						//	var z = Math.floor(Math.random() * Chunk.sizeZ)
						//	var middleChunk = World.chunks['0,0,0']
						//
						//	var blockPos = middleChunk.getBlockPos(x, y, z)
						//	blockPos.setBlockData( blockPos.getBlockData() === 4 ? 0 :  4 )
						//}

						PlayerControls.update(dt)

						// move chunks?
						var playerBlockPos = World.getBlockPosFromWorldPoint(camera.position)
						if (playerBlockPos.chunk.id !== lastPlayerChunkId) {
							console.log("center chunk moved!")
							World.updateNearbyChunks(playerBlockPos.chunk)
							lastPlayerChunkId = playerBlockPos.chunk.id
						}

						document.getElementById("coords").innerHTML = `x = ${Math.round(camera.position.x)}, y = ${Math.round(camera.position.y)}, z = ${Math.round(camera.position.z)}<br>` + playerBlockPos.toString()

						raycaster.setFromCamera( new THREE.Vector2(), camera ) // hijacking some linear algebra to set raycaster.ray
						var max_d = 5000
						voxelRaycast = World.raycast(raycaster.ray, max_d)
						if (voxelRaycast) {
							blockOutline.position.copy(voxelRaycast.blockPos.getWorldPoint())
							blockOutline.geometry.setDrawRange(5 * voxelRaycast.side.id, 5) // vector3 * 5 vertices for a closed path
							blockOutline.visible = true
						}
						else {
							blockOutline.visible = false
						}


						World.cleanAllDirtyChunks()

						renderer.render(scene, camera)

						requestAnimationFrame( render );
						stats.elapsed.end()
						stats.fps.update()
					};

					requestAnimationFrame( render )
				}
			})
		</script>
	</body>
</html>