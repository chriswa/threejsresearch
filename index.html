<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Proto</title>
		<style>
			html, body { margin: 0; overflow: hidden; }
			canvas { width: 100%; height: 100% }
			#coords { position: absolute; top: 0; right: 0; color: white; background-color: black; text-align: right; padding: 2px; }
			#crosshair { width: 10px; height: 20px; position: absolute; top: 50%; left: 50%; margin: -10px 0 0 -5px; color: white; text-align: center; }
		</style>
	</head>
	<body>
		<div id="coords"></div>
		<div id="crosshair">+</div>
		<script src="lodash.js"></script>
		<script src="RLE.js"></script>
		<script src="stats.js"></script>
		<script src="perlin.js"></script>
		<script src="three.js"></script>
		<script src="FirstPersonControls.js"></script>
		<script src="PlayerControls.js"></script>
		<script src="QuadWriter.js"></script>
		<script src="ChunkMesh.js"></script>
		<script src="Chunk.js"></script>
		<script src="BlockPos.js"></script>
		<script src="Sides.js"></script>
		<script src="BlockTypes.js"></script>
		<script src="World.js"></script>
		<script>
			var stats = {}
			stats.fps = new Stats()
			stats.fps.showPanel(0)
			stats.fps.domElement.style.position = 'absolute'
			document.body.appendChild( stats.fps.domElement )
			stats.elapsed = new Stats()
			stats.elapsed.showPanel(1)
			stats.elapsed.domElement.style.position = 'absolute'
			stats.elapsed.domElement.style.left = '80px'
			document.body.appendChild( stats.elapsed.domElement )



			var mainTexture
			var loader = new THREE.TextureLoader()
			
			var renderer = new THREE.WebGLRenderer()
			var gl = renderer.context
			renderer.setPixelRatio( window.devicePixelRatio )
			renderer.setSize( window.innerWidth, window.innerHeight )
			renderer.setClearColor( new THREE.Color( 0x7ec0ee ) )
			document.body.appendChild( renderer.domElement )

			var scene  = new THREE.Scene()
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 2000000  )
			camera.position.z = 7.5
			camera.position.y = 11.5
			camera.position.x = 7.5

			window.addEventListener( 'resize', () => {
				camera.aspect = window.innerWidth / window.innerHeight
				camera.updateProjectionMatrix()
				renderer.setSize( window.innerWidth, window.innerHeight )
			}, false )

			//var cube1 = new THREE.Mesh( new THREE.BoxGeometry( 1.1, 1.1, 1.1 ), new THREE.MeshBasicMaterial( {color: 0x0099cc} ) )
			//scene.add( cube1 )
			//var cube2 = new THREE.Mesh( new THREE.BoxGeometry( 0.2, 0.2, 0.2 ), new THREE.MeshBasicMaterial( {color: 0x99cc00} ) )
			//scene.add( cube2 )


			var voxelRaycast
			camera.addEventListener('click', event => {

				if (!voxelRaycast) { return }

				if (event.button === 0) {
					voxelRaycast.blockPos.setBlockData(0)
				}
				else {
					voxelRaycast.blockPos.getAdjacentBlockPos(voxelRaycast.side).setBlockData(BlockTypesByName.planks.id)
				}

			})

			var ChunkLoading = {
				followsCamera: false,
				range: 0,
				centreChunkPos: new THREE.Vector3(0, 0, 0),
				update(force) {
					if (this.followsCamera && !force) {
						var cameraChunkPos = camera.position.clone().divideScalar(Chunk.size).floor()
						if (cameraChunkPos.equals(this.centreChunkPos)) { return } // centre hasn't changed, skip update
						this.centreChunkPos.copy(cameraChunkPos)
					}
					World.loadAndUnloadChunksAroundChunkPos(this.centreChunkPos, this.range)
				},
			}

			loader.load('minecraft15.png', texture => { // e.g. loading multiple textures with promise.all: http://stackoverflow.com/questions/7919516/using-textures-in-three-js
				texture.minFilter = THREE.NearestFilter
				texture.magFilter = THREE.NearestFilter
				mainTexture = texture

				World.loadAndUnloadChunksAroundChunkPos(ChunkLoading.centreChunkPos, ChunkLoading.range) // requires mainTexture

				start()

				function start() {

					var raycaster = new THREE.Raycaster()

					var clock = new THREE.Clock()
					var elapsedTime = 0

					PlayerControls.init(camera)
					PlayerControls.fps.lon = 90
					PlayerControls.fps.lat = -30

					var blockOutlineVerts = []
					var blockOutlineOffset = 0.01
					var blockOutlineScale = 0.99
					Sides.each(side => {
						var vertIndices = [0, 1, 2, 3, 0]
						for (var i = 0; i < vertIndices.length; i += 1) {
							blockOutlineVerts.push( (side.verts[ vertIndices[i] * 3 + 0 ] - 0.5) * blockOutlineScale + 0.5 + side.dx * blockOutlineOffset )
							blockOutlineVerts.push( (side.verts[ vertIndices[i] * 3 + 1 ] - 0.5) * blockOutlineScale + 0.5 + side.dy * blockOutlineOffset )
							blockOutlineVerts.push( (side.verts[ vertIndices[i] * 3 + 2 ] - 0.5) * blockOutlineScale + 0.5 + side.dz * blockOutlineOffset )
						}
					})
					var blockOutlineGeometry = new THREE.BufferGeometry()
					blockOutlineGeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array(blockOutlineVerts), 3 ) )
					var blockOutlineMaterial = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 1, transparent: true } )
					blockOutline = new THREE.Line( blockOutlineGeometry, blockOutlineMaterial )
					scene.add( blockOutline )



					var render = function () {
						stats.elapsed.begin()
						var dt = Math.min(clock.getDelta(), 0.2)
						elapsedTime += dt

						PlayerControls.update(dt)

						// DEBUG: ever onward! for fps research!
						if (!PlayerControls.pointerLocked) {
							//camera.position.z += dt * 50
						}

						ChunkLoading.update()

						document.getElementById("coords").innerHTML = `x = ${Math.round(camera.position.x)}, y = ${Math.round(camera.position.y)}, z = ${Math.round(camera.position.z)}`

						raycaster.setFromCamera( new THREE.Vector2(), camera ) // hijacking some linear algebra to set raycaster.ray
						var max_d = 5000
						voxelRaycast = World.raycast(raycaster.ray, max_d)
						if (voxelRaycast) {
							blockOutline.position.copy(voxelRaycast.blockPos.getWorldPoint())
							blockOutline.geometry.setDrawRange(5 * voxelRaycast.side.id, 5) // vector3 * 5 vertices for a closed path
							blockOutline.visible = true
						}
						else {
							blockOutline.visible = false
						}


						World.updateChunks()

						renderer.render(scene, camera)

						requestAnimationFrame( render )
						stats.elapsed.end()
						stats.fps.update()
					}

					requestAnimationFrame( render )
				}
			})
		</script>
	</body>
</html>